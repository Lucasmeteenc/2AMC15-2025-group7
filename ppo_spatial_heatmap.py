import argparse
import logging
from pathlib import Path
import warnings
import os

import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
import numpy as np
import seaborn as sns
import torch

from ppo_agent import PPOAgent, PPOConfig
from ppo_utils import CheckpointManager, PPOError
from environments.medium_delivery_env import MediumDeliveryEnv
from maps import MAIL_DELIVERY_MAPS

# --------------------------------------------------------------------------- #
# Configuration constants
# --------------------------------------------------------------------------- #
# for experiments: (9.0,4.0),(0.5,9.0),(1.0,2.0)
# for inside map: (5.0,2.0),(1.0,9.0),(1.0,1.0)
FIXED_START_POSITION = (1.0, 1.0)  # interesting coords for default: (9.0, 4.0), theta=0
FIXED_START_THETA = 0  #                        inside: (5.0, 2.0), theta=0
SCALE = 1.0  # Scale factor for marker sizes

# --------------------------------------------------------------------------- #
# Utility functions
# --------------------------------------------------------------------------- #


def render_map(ax, map_config):
    """Draw the map background, obstacles, depot, delivery point, and start."""
    width, height = map_config["size"]
    ax.set_xlim(0, width)
    ax.set_ylim(0, height)
    ax.set_aspect("equal", adjustable="box")
    ax.set_xticks([])
    ax.set_yticks([])

    # Obstacles
    for x0, y0, x1, y1 in map_config["obstacles"]:
        ax.add_patch(Rectangle((x0, y0), x1 - x0, y1 - y0, color="gray", alpha=0.5))

    # Depot (green square)
    depot_x, depot_y = map_config["depot"]
    ax.add_patch(
        Rectangle(
            (depot_x - 0.2 * SCALE, depot_y - 0.2 * SCALE),
            0.4 * SCALE,
            0.4 * SCALE,
            color="green",
        )
    )

    # Fixed start position (blue circle)
    start_x, start_y = FIXED_START_POSITION
    ax.plot(
        start_x, start_y, marker="o", markersize=6, color="lightblue", label="Start"
    )

    # Delivery point (red X)
    deliv_x, deliv_y = map_config["delivery"]
    off = 0.2 * SCALE
    ax.plot(
        [deliv_x - off, deliv_x + off],
        [deliv_y - off, deliv_y + off],
        color="red",
        linewidth=2 * SCALE,
    )
    ax.plot(
        [deliv_x - off, deliv_x + off],
        [deliv_y + off, deliv_y - off],
        color="red",
        linewidth=2 * SCALE,
    )


def create_environment(cfg: PPOConfig):
    """Instantiate the MediumDelivery environment with a fixed seed."""
    return MediumDeliveryEnv(
        map_config=MAIL_DELIVERY_MAPS[cfg.map_name], render_mode=None, seed=42
    )


def load_model(path: str, cfg: PPOConfig, device: torch.device):
    """Load a pre-trained PPO actor network into a freshly-built PPOAgent."""
    env = create_environment(cfg)

    # Build an *untrained* PPO agent so we can load weights
    agent = PPOAgent(cfg, device)
    obs_dim = env.observation_space.shape[0]
    act_dim = env.action_space.n
    agent.setup_networks(obs_dim, act_dim)

    # --------------------------------------------------------------------- #
    # Flexible loading logic – handle both full checkpoints and raw state_dicts
    # --------------------------------------------------------------------- #
    if not Path(path).is_file():
        raise FileNotFoundError(f"Model file not found: {path}")

    state = torch.load(path, map_location=device, weights_only=False)

    # Case A: our .pth is a full checkpoint generated by CheckpointManager
    if isinstance(state, dict) and "actor_state_dict" in state:
        agent.actor.load_state_dict(state["actor_state_dict"])
    # Case B: the file is *just* the actor state_dict
    elif isinstance(state, dict):
        agent.actor.load_state_dict(state)
    else:
        raise PPOError(
            "Unrecognised checkpoint format for PPO model – expecting either a CheckpointManager file or a raw state_dict containing layer weights."
        )

    agent.actor.to(device).eval()
    return agent


def evaluate_and_spatial_heatmap(
    model_path: str,
    map_name: str,
    trials: int,
    bandwidth: float,
    cmap_name: str,
    save_path: str,
):
    """Run multiple evaluation episodes with the PPO agent and plot a KDE heat-map of visited positions."""

    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    cfg = PPOConfig(map_name=map_name)
    env = create_environment(cfg)
    agent = load_model(model_path, cfg, device)

    positions: list[tuple[float, float]] = []

    for ep in range(trials):
        obs_np, _ = env.reset()
        # Override start pose to align with DQN version for apples-to-apples comparison
        env.agent_x, env.agent_y = FIXED_START_POSITION
        env.agent_theta = FIXED_START_THETA
        obs_np = env._get_obs()

        done = False
        score_sum = 0.0
        step_cnt = 0

        while not done:
            # Record position before the move
            positions.append((env.agent_x, env.agent_y))

            state = torch.from_numpy(np.asarray(obs_np, np.float32)).to(device)

            # Deterministic action selection (greedy w.r.t. logits)
            with torch.no_grad():
                logits = agent.actor(state)
                action = torch.argmax(logits, dim=-1).item()

            # Environment step
            next_obs_np, reward, terminated, truncated, _ = env.step(action)
            score_sum += reward
            done = terminated or truncated
            obs_np = next_obs_np
            step_cnt += 1

        logging.info(
            "Episode %d/%d - steps: %d, score: %.2f",
            ep + 1,
            trials,
            step_cnt,
            score_sum,
        )

    env.close()

    # --------------------------------------------------------------------- #
    # Plot heat-map
    # --------------------------------------------------------------------- #
    fig, ax = plt.subplots(figsize=(8, 8))
    render_map(ax, MAIL_DELIVERY_MAPS[map_name])

    if positions:
        xs, ys = zip(*positions)
        cmap = plt.get_cmap(cmap_name)

        sns.kdeplot(
            x=xs,
            y=ys,
            cmap=cmap,
            fill=True,
            alpha=0.6,
            n_levels=100,
            bw_adjust=bandwidth,
            ax=ax,
        )

    final_path = os.path.join("sheatmap_results", save_path)
    ax.set_xlabel("")
    ax.set_ylabel("")
    ax.set_title(f"PPO Agent Continuous Spatial Heat-map ({trials} episodes)")
    plt.tight_layout()
    plt.savefig(final_path, dpi=300)
    plt.close()
    logging.info("Spatial heat-map saved to %s", final_path)


# --------------------------------------------------------------------------- #
# Main entry point
# --------------------------------------------------------------------------- #


def main():
    parser = argparse.ArgumentParser(description="Visualise PPO spatial heat-map")
    parser.add_argument(
        "--model",
        default="best_models/default/ppo.pth",
        help="Path to the PPO .pth model file",
    )
    parser.add_argument(
        "--map",
        default="default",
        choices=list(MAIL_DELIVERY_MAPS.keys()),
        help="Map name",
    )
    parser.add_argument(
        "--trials",
        type=int,
        default=100,
        help="Number of evaluation episodes",
    )
    parser.add_argument(
        "--bw",
        type=float,
        default=0.5,
        help="Bandwidth scaling for KDE (lower = hugs path)",
    )
    parser.add_argument(
        "--cmap",
        default="viridis",
        help="Matplotlib color-map name (e.g. jet, viridis, magma)",
    )
    parser.add_argument(
        "--out",
        default="ppo_spatial_heatmap.png",
        help="Output PNG path",
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Increase logging verbosity",
    )
    args = parser.parse_args()

    # Configure warnings and logging
    warnings.filterwarnings("ignore", category=UserWarning)
    logging.basicConfig(
        level=logging.DEBUG if args.verbose else logging.INFO, format="%(message)s"
    )

    evaluate_and_spatial_heatmap(
        model_path=args.model,
        map_name=args.map,
        trials=args.trials,
        bandwidth=args.bw,
        cmap_name=args.cmap,
        save_path=args.out,
    )


if __name__ == "__main__":
    main()
